- [バッドノウハウ](#バッドノウハウ)
  - [配列型(非スカラ値)の使用](#配列型非スカラ値の使用)
  - [ダブルミーニング](#ダブルミーニング)
  - [単一参照テーブル](#単一参照テーブル)
  - [テーブル分割](#テーブル分割)
    - [水平分割](#水平分割)
    - [垂直分割](#垂直分割)
      - [集約](#集約)
  - [不適切なキー](#不適切なキー)
  - [ダブルマスタ](#ダブルマスタ)
- [グレーノウハウ](#グレーノウハウ)
  - [代理キー(サロゲートキー)](#代理キーサロゲートキー)
    - [オートナンバリング](#オートナンバリング)
      - [DBの機能での実現方法](#dbの機能での実現方法)
      - [アプリ側での実現方法](#アプリ側での実現方法)
    - [自然キーによる解決](#自然キーによる解決)
  - [列持ちテーブル](#列持ちテーブル)
    - [利点](#利点)
    - [欠点](#欠点)
    - [行持ちテーブルを使用する](#行持ちテーブルを使用する)
  - [アドホックな集計キー](#アドホックな集計キー)
    - [解決策1](#解決策1)
    - [解決策2](#解決策2)
    - [解決策3](#解決策3)
  - [多段ビュー](#多段ビュー)


# バッドノウハウ

以下のノウハウは3つの点で採用すべきではない。
- 可読性が悪い
- 設計変更が難しい  
変更時にアプリケーションにも変更が必要になる。
- データ構造によってコードの良し悪しが決まる  
データ構造に問題があると、コードのパフォーマンスも悪くなる。

## 配列型(非スカラ値)の使用

スカラ値は意味的に理解できるもの。  
分解しすぎて理解できなくなったものはスカラ値ではない。

## ダブルミーニング

同じ列に異なる意味の値を入れること。  
列を変数とみなしてしまうことで起こる。

## 単一参照テーブル

似た構造の意味の異なる複数のテーブルを1つにまとめてしまうこと。  
レコードによって列の意味が変わってしまう。

## テーブル分割

### 水平分割

テーブルを年度などで別テーブルに分割すること。
全年度を対象とした検索や年が増えるごとにテーブルも増えてしまう。
DBMSの機能のパーティションを使用することで解決できる。

### 垂直分割

特定のSQLで使用している列のみを別テーブルに分割すること。  
可逆性がある分解ではあるが、論理的な意味をもたない。
集約で代替可能。

#### 集約

- 列の絞り込み  
垂直分割では特定のSQLで使用する列を完全に別テーブルとして分割していたが、列の絞り込みでは、元のテーブルはそのままで参照する列のみを別テーブルとして作成する(データマート)。  
元のテーブルが更新されたらデータマートも更新する必要があり、更新にタイムラグがあっても問題ないかなど要件に照らし合わせて使用する必要がある。

- サマリーテーブル  
元のテーブルの集計結果をあらかじめ別テーブルに保存しておくこと。  
列の絞り込みと同様、タイムラグによるデメリットがある。  

## 不適切なキー

主キー、外部キー、結合キーに用いる型に可変長文字列型を使用すること。  
結合で値が等しくならず、結合できなくなる。  
キーには固定長文字列のコードを使用する。

## ダブルマスタ

同じ役割を持つマスタテーブルが2つ存在すること。  
システムの統合を行った際に起きることがある。

# グレーノウハウ

## 代理キー(サロゲートキー)

人工的に一意になるように作られたキー。  
以下のような状況で作られる。
 
1. 主キーになるような一意キーが存在しない

2. 一意キーはあるが、サイクリックに使い回される  
欠番になった値を別のレコードで使用するなど

3. 一意キーはあるが、途中で指す内容が変わる  
町の合併などでどちらか一方の町のコードを新たな町のコードに使用するなど

### オートナンバリング

代理キーに求められるのは基本的に一意であることのみ。
主キーとして使用するために以下の2点を守る必要がある。
1. 重複値が生じないこと
2. 歯抜けが生じないこと

#### DBの機能での実現方法

- シーケンスオブジェクト
- ID列

指定できるオプションや移植性が低い点から、ID列よりシーケンスオブジェクトの方がいい。

#### アプリ側での実現方法

採番テーブルを作成し、そのテーブルの値を取得して採番する。
排他制御が複雑になったりトランザクション分離レベルがDBMSによって異なったりするため、移植が難しくなる。
あえてアプリ側で行わず(車輪の再発明)シーケンスオブジェクトを使用することが望ましい。

### 自然キーによる解決

1の場合は、DB側では解決できない。  
2,3の場合は以下の自然キーとなる列を追加し、複合主キーとすることで解決できる。

- タイムスタンプ  
いつの時点であるかを表すタイムスタンプ列(年度を表す列など)を追加し、業務的に意味のあるコード値と組み合わせて主キーにする。  

- インターバル  
開始時期と終了時期を表す列を追加し、開始時期の列を業務的に意味のあるコード値と組み合わせて主キーにする。

## 列持ちテーブル

列の数によって配列を表現すること。

### 利点

- データ構造がわかりやすい
- データの入出力がアプリ側と合わせやすい  
欲しい列をSELECTするだけで良い。

### 欠点

- 列の増減が難しい
- 無用なNULLを扱う必要がある

### 行持ちテーブルを使用する

列持ちではなく、行持ちテーブルの方が欠点が少ない。
列で表現していた配列を採番カラムを追加して行で表現する。

## アドホックな集計キー

レコードを特定のグループ(地域など)で集計したいときに、そのグループを表す列を追加すること。
コード体系が変化したり、別のグループを表す列を追加する必要が出てきてパフォーマンスが悪くなる。

### 解決策1

キーを別のテーブルに分離する。  
メンテナンスが容易になるが、結合が必要なためパフォーマンスの問題は解決しない。

### 解決策2

ビューを作成する。
オリジナルはそのままで、ビューで集計キーを追加することでパフォーマンスの問題を解決できる。

### 解決策3

GROUP BY区の中でグループを表す列を追加する。  
CASE式を利用して、グループを表す列を追加する。

## 多段ビュー

ビュー内で別のビューを参照すること。  
ビュー内で別のビューを展開することで、SELECT文を実行する回数が増えてパフォーマンスが悪くなる。  
